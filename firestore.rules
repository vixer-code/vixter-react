rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // =====================================================
    // HELPER FUNCTIONS
    // =====================================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user is the document owner
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Check if user is admin (you should define admin UIDs)
    function isAdmin() {
      return request.auth.uid in ['admin_uid_1', 'admin_uid_2']; // Replace with actual admin UIDs
    }
    
    // Check if user is admin based on user document
    function isAdminByProfile() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.admin == true;
    }
    
    // Check if request is from Cloud Functions (for watermarking)
    function isCloudFunction() {
      return request.auth != null && request.auth.token.firebase.sign_in_provider == 'custom';
    }
    
    // =====================================================
    // WALLET COLLECTION RULES
    // =====================================================
    
    match /wallets/{userId} {
      // Users can only read their own wallet
      allow read: if isAuthenticated() && isOwner(userId);
      
      // Only Cloud Functions can create/update wallets (no direct client writes)
      // This ensures all balance changes go through server-side validation
      allow write: if false;
      
      // Admin read access for support
      allow read: if isAdmin();
    }
    
    // =====================================================
    // TRANSACTIONS COLLECTION RULES
    // =====================================================
    
    match /transactions/{transactionId} {
      // Users can only read their own transactions
      allow read: if isAuthenticated() && 
                    (isOwner(resource.data.userId) || 
                     isOwner(resource.data.fromUserId) || 
                     isOwner(resource.data.toUserId));
      
      // Allow list queries for authenticated users to read their own transactions
      allow list: if isAuthenticated();
      
      // Only Cloud Functions can create transactions (no direct client writes)
      // This ensures transaction integrity and prevents fraud
      allow write: if false;
      
      // Admin read access for support and auditing
      allow read: if isAdmin();
    }
    
    // =====================================================
    // STRIPE PAYMENTS COLLECTION RULES
    // =====================================================
    
    match /stripePayments/{sessionId} {
      // Users can only read their own payment sessions
      allow read: if isAuthenticated() && 
                    isOwner(resource.data.userId);
      
      // Only Cloud Functions can write payment data
      allow write: if false;
      
      // Admin access for payment reconciliation
      allow read: if isAdmin();
    }
    
    // =====================================================
    // USERS COLLECTION RULES
    // =====================================================
    
    match /users/{userId} {
      // Users can read/write their own profile
      allow read, write: if isAuthenticated() && isOwner(userId);
      
      // Users can read other users' public profile fields for messaging and watermarking
      // This allows reading displayName, username, photoURL, status for conversations and pack content
      allow read: if isAuthenticated();
      
      // Cloud Functions need read access for watermarking (vendor info)
      allow read: if isCloudFunction();
      
      // Allow users to update followersCount and followingCount for follow/unfollow operations
      allow update: if isAuthenticated() && 
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['followersCount', 'followingCount', 'updatedAt']);
      
      // Admin access
      allow read, write: if isAdmin();
      
      // =====================================================
      // FOLLOWERS SUBCCOLLECTION RULES
      // =====================================================
      
      match /followers/{followerId} {
        // Anyone authenticated can read followers (for public profiles)
        allow read: if isAuthenticated();
        
        // Anyone authenticated can add themselves as a follower
        allow write: if isAuthenticated() && isOwner(followerId);
        
        // Admin access
        allow read, write: if isAdmin();
      }
      
      // =====================================================
      // FOLLOWING SUBCCOLLECTION RULES
      // =====================================================
      
      match /following/{followingId} {
        // Anyone authenticated can read following lists (for public profiles)
        allow read: if isAuthenticated();
        
        // Users can write to their own following list
        allow write: if isAuthenticated() && isOwner(userId);
        
        // Admin access
        allow read, write: if isAdmin();
      }
    }
    
    // =====================================================
    // PACKS COLLECTION RULES
    // =====================================================
    
    match /packs/{packId} {
      // Anyone can read packs (public content)
      allow read: if true;
      
      // Cloud Functions need read access for watermarking (pack metadata)
      allow read: if isCloudFunction();
      
      // Only pack owners can create/update their packs
      allow create, update: if isAuthenticated() && 
                              isOwner(request.resource.data.vendorId);
      
      // Only pack owners can delete their packs
      allow delete: if isAuthenticated() && 
                      isOwner(resource.data.vendorId);
      
      // Admin access
      allow read, write: if isAdmin();
    }
    
    // =====================================================
    // SERVICES COLLECTION RULES
    // =====================================================
    
    match /services/{serviceId} {
      // Anyone can read services (public content)
      allow read: if true;
      
      // Only service owners can create/update their services
      allow create, update: if isAuthenticated() && 
                              isOwner(request.resource.data.providerId);
      
      // Only service owners can delete their services
      allow delete: if isAuthenticated() && 
                      isOwner(resource.data.providerId);
      
      // Admin access
      allow read, write: if isAdmin();
    }
    
    // =====================================================
    // VIXTIPS COLLECTION RULES
    // =====================================================
    
    match /vixtips/{vixtipId} {
      // Anyone can read vixtips (public content)
      allow read: if true;
      
      // Only authenticated users can create vixtips
      allow create: if isAuthenticated();
      
      // Only vixtip creators can update their vixtips
      allow update: if isAuthenticated() && 
                      isOwner(resource.data.fromUserId);
      
      // Only vixtip creators can delete their vixtips
      allow delete: if isAuthenticated() && 
                      isOwner(resource.data.fromUserId);
      
      // Admin access
      allow read, write: if isAdmin();
    }
    
    // =====================================================
    // POSTS COLLECTION RULES
    // =====================================================
    
    match /posts/{postId} {
      // Anyone can read posts (public content)
      allow read: if true;
      
      // Only post authors can create/update their posts
      allow create, update: if isAuthenticated() && 
                              isOwner(request.resource.data.authorId);
      
      // Only post authors can delete their posts
      allow delete: if isAuthenticated() && 
                      isOwner(resource.data.authorId);
      
      // Admin access
      allow read, write: if isAdmin();
    }
    
    // =====================================================
    // SERVICE ORDERS COLLECTION RULES
    // =====================================================
    
    match /serviceOrders/{orderId} {
      // Buyers and sellers can read their orders (buyerId at root level only)
      allow read: if isAuthenticated() && 
                    (isOwner(resource.data.buyerId) || 
                     isOwner(resource.data.sellerId));
      
      // Allow limited read access for statistics calculation (count completed orders)
      allow read: if isAuthenticated() && 
                    resource.data.status in ['CONFIRMED', 'COMPLETED', 'AUTO_RELEASED'];
      
      // Service order creation via Cloud Functions only (but allow client reads)
      allow create: if isAuthenticated() && 
                      isOwner(request.resource.data.buyerId) &&
                      isValidServiceOrder(request.resource.data);
      
      // Allow status updates for order workflow (buyerId at root level only)
      allow update: if isAuthenticated() && 
                      (isOwner(resource.data.buyerId) || 
                       isOwner(resource.data.sellerId)) &&
                      isValidStatusUpdate(resource.data, request.resource.data);
      
      allow delete: if false;
      
      // Admin access
      allow read, write: if isAdmin();
    }
    
    // Helper function for service order validation
    function isValidServiceOrder(data) {
      return data.keys().hasAll(['serviceId', 'sellerId', 'buyerId', 'vpAmount', 'status']) &&
             data.status == 'PENDING_ACCEPTANCE' &&
             data.vpAmount > 0;
    }
    
    // Helper function for status update validation
    function isValidStatusUpdate(currentData, newData) {
      let currentStatus = currentData.status;
      let newStatus = newData.status;
      
      return (
        // Seller can accept or decline pending orders
        (request.auth.uid == currentData.sellerId && 
         currentStatus == 'PENDING_ACCEPTANCE' && 
         (newStatus == 'ACCEPTED' || newStatus == 'CANCELLED')) ||
        
        // Seller can mark accepted orders as delivered
        (request.auth.uid == currentData.sellerId && 
         currentStatus == 'ACCEPTED' && 
         newStatus == 'DELIVERED') ||
        
        // Buyer can confirm delivered orders
        (request.auth.uid == currentData.buyerId && 
         currentStatus == 'DELIVERED' && 
         newStatus == 'CONFIRMED') ||
         
        // System can auto-release
        (currentStatus == 'DELIVERED' && 
         newStatus == 'AUTO_RELEASED')
      );
    }
    
    // =====================================================
    // PACK ORDERS COLLECTION RULES
    // =====================================================
    
    match /packOrders/{orderId} {
      // Buyers and sellers can read their orders
      allow read: if isAuthenticated() && 
                    (isOwner(resource.data.buyerId) || 
                     isOwner(resource.data.sellerId));
      
      // Cloud Functions need read access for watermarking (order validation)
      allow read: if isCloudFunction();
      
      // Allow limited read access for statistics calculation (count completed orders)
      allow read: if isAuthenticated() && 
                    resource.data.status in ['CONFIRMED', 'COMPLETED', 'AUTO_RELEASED'];
      
      // Pack order creation via Cloud Functions only (but allow client reads)
      allow create: if isAuthenticated() && 
                      isOwner(request.resource.data.buyerId) &&
                      isValidPackOrder(request.resource.data);
      
      // Allow status updates for order workflow
      allow update: if isAuthenticated() && 
                      (isOwner(resource.data.buyerId) || 
                       isOwner(resource.data.sellerId)) &&
                      isValidPackStatusUpdate(resource.data, request.resource.data);
      
      allow delete: if false;
      
      // Admin access
      allow read, write: if isAdmin();
    }
    
    // Helper function for pack order validation
    function isValidPackOrder(data) {
      return data.keys().hasAll(['packId', 'buyerId', 'sellerId', 'vpAmount', 'status']) &&
             data.status == 'PENDING_ACCEPTANCE' &&
             data.vpAmount > 0;
    }
    
    // Helper function for pack status update validation
    function isValidPackStatusUpdate(currentData, newData) {
      let currentStatus = currentData.status;
      let newStatus = newData.status;
      
      return (
        // Seller can accept or decline pending orders
        (request.auth.uid == currentData.sellerId && 
         currentStatus == 'PENDING_ACCEPTANCE' && 
         (newStatus == 'ACCEPTED' || newStatus == 'CANCELLED')) ||
        
        // Seller can mark accepted orders as delivered
        (request.auth.uid == currentData.sellerId && 
         currentStatus == 'ACCEPTED' && 
         newStatus == 'DELIVERED') ||
        
        // Buyer can confirm delivered orders
        (request.auth.uid == currentData.buyerId && 
         currentStatus == 'DELIVERED' && 
         newStatus == 'CONFIRMED') ||
         
        // System can auto-release
        (currentStatus == 'DELIVERED' && 
         newStatus == 'AUTO_RELEASED')
      );
    }

    // =====================================================
    // KYC COLLECTION RULES
    // =====================================================
    
    match /kyc/{userId} {
      // Users can only read their own KYC data
      allow read: if isAuthenticated() && isOwner(userId);
      
      // Users can create their own KYC document
      allow create: if isAuthenticated() && isOwner(userId);
      
      // Users can update their own KYC document (for status updates)
      allow update: if isAuthenticated() && isOwner(userId);
      
      // Only admins can delete KYC documents
      allow delete: if isAdmin();
      
      // Admin access for verification and management
      allow read, write: if isAdmin();
    }
    
    // =====================================================
    // REVIEWS COLLECTION RULES
    // =====================================================
    
    match /reviews/{reviewId} {
      // Any authenticated user can read reviews (for profile display and statistics)
      allow read: if isAuthenticated();
      
      // Allow list queries for statistics calculation (pack/service ratings)
      allow list: if isAuthenticated();
      
      // Users can create reviews (with validation)
      allow create: if isAuthenticated() && 
                      isOwner(request.resource.data.reviewerId) &&
                      isValidReview(request.resource.data);
      
      // Users can update their own reviews
      allow update: if isAuthenticated() && 
                      isOwner(resource.data.reviewerId) &&
                      isValidReviewUpdate(resource.data, request.resource.data);
      
      // Users can delete their own reviews
      allow delete: if isAuthenticated() && 
                      isOwner(resource.data.reviewerId);
      
      // Admin access
      allow read, write: if isAdmin();
    }
    
    // Helper function for review validation
    function isValidReview(data) {
      return data.keys().hasAll(['type', 'reviewerId', 'targetUserId', 'rating', 'comment']) &&
             data.rating >= 1 && data.rating <= 5 &&
             data.comment.size() > 0 && data.comment.size() <= 200 &&
             (data.type == 'service' || data.type == 'pack' || data.type == 'behavior');
    }
    
    // Helper function for review update validation
    function isValidReviewUpdate(currentData, newData) {
      return newData.rating >= 1 && newData.rating <= 5 &&
             newData.comment.size() > 0 && newData.comment.size() <= 200 &&
             newData.type == currentData.type &&
             newData.reviewerId == currentData.reviewerId &&
             newData.targetUserId == currentData.targetUserId;
    }

    // =====================================================
    // BLOCKS COLLECTION RULES
    // =====================================================
    
    match /blocks/{blockId} {
      // Users can read their own blocks (to check if they blocked someone)
      allow read: if isAuthenticated() && 
                    (isOwner(resource.data.blockerId) || 
                     isOwner(resource.data.blockedId));
      
      // Users can create blocks (blocking someone)
      allow create: if isAuthenticated() && 
                      isOwner(request.resource.data.blockerId) &&
                      isValidBlock(request.resource.data);
      
      // Users can delete their own blocks (unblocking someone)
      allow delete: if isAuthenticated() && 
                      isOwner(resource.data.blockerId);
      
      // Admin access
      allow read, write: if isAdmin();
    }
    
    // Helper function for block validation
    function isValidBlock(data) {
      return data.keys().hasAll(['blockerId', 'blockedId', 'timestamp']) &&
             data.blockerId != data.blockedId; // Can't block yourself
    }

    // =====================================================
    // ANNOUNCEMENTS COLLECTIONS RULES
    // =====================================================
    
    // Announcements for Lobby
    match /announcements_lobby/{announcementId} {
      // Anyone authenticated can read announcements
      allow read: if isAuthenticated();
      
      // Only admins can create announcements
      allow create: if isAdminByProfile() && isValidAnnouncement(request.resource.data);
      
      // Only admins can update/delete announcements
      allow update, delete: if isAdminByProfile();
      
      // Legacy admin access (if UIDs are defined)
      allow read, write: if isAdmin();
    }
    
    // Announcements for Vixies
    match /announcements_vixies/{announcementId} {
      // Anyone authenticated can read announcements
      allow read: if isAuthenticated();
      
      // Only admins can create announcements
      allow create: if isAdminByProfile() && isValidAnnouncement(request.resource.data);
      
      // Only admins can update/delete announcements
      allow update, delete: if isAdminByProfile();
      
      // Legacy admin access (if UIDs are defined)
      allow read, write: if isAdmin();
    }
    
    // Announcements for Vixink
    match /announcements_vixink/{announcementId} {
      // Anyone authenticated can read announcements
      allow read: if isAuthenticated();
      
      // Only admins can create announcements
      allow create: if isAdminByProfile() && isValidAnnouncement(request.resource.data);
      
      // Only admins can update/delete announcements
      allow update, delete: if isAdminByProfile();
      
      // Legacy admin access (if UIDs are defined)
      allow read, write: if isAdmin();
    }
    
    // Helper function for announcement validation
    function isValidAnnouncement(data) {
      return data.keys().hasAll(['authorId', 'authorName', 'createdAt', 'type', 'feedType']) &&
             data.type == 'announcement' &&
             data.authorId == request.auth.uid &&
             (data.feedType == 'lobby' || data.feedType == 'vixies' || data.feedType == 'vixink');
    }

    // =====================================================
    // DEFAULT DENY RULE
    // =====================================================
    
    // Deny all other operations by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}